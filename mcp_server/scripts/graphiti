#!/bin/bash
set -e # Exit immediately if a command exits with a non-zero status.

# Function to display usage information
usage() {
  echo "Usage: graphiti [-h|--help] [COMMAND] [ARGS...]"
  echo
  echo "Commands:"
  echo "  init PROJECT_NAME [DIR]        Initialize a project: run link-dev-files and setup-rules."
  echo "  add-entities SET_NAME          Create a new entity type set with an example entity in the mcp-graphiti repo."
  echo "  setup-rules PROJECT_NAME [DIR] Setup Cursor rules (.mdc files) for Graphiti in a target project directory."
  echo "  link-dev-files [DIR]           (Default if no command) Create dev symlinks (entity_types, docker-compose.yml)."
  echo "  up [-d]                        Start all containers using docker compose. Use -d for detached mode."
  echo "  down                           Stop and remove all containers using docker compose."
  echo
  echo "Arguments for init & setup-rules:"
  echo "  PROJECT_NAME  Name of the target project (used for schema filename)."
  echo "  DIR           Optional. Target project root directory. Defaults to current directory (.)."
  echo
  echo "Arguments for link-dev-files:"
  echo "  DIR           Optional. Target directory for dev links. Defaults to current directory (.)."
  echo
  echo "Options:"
  echo "  -h, --help        Show this help message and exit."
  echo "  -d                Run containers in detached mode (background) with 'up' command."
  echo
  echo "Prerequisites:"
  echo "  The MCP_GRAPHITI_REPO_PATH environment variable must be set to the"
  echo "  absolute path of your local mcp-graphiti repository."
  echo "  Example: export MCP_GRAPHITI_REPO_PATH=/path/to/mcp-graphiti"
  exit 0
}

# Function to convert set name to a class name (e.g., my-cool-set to MyCoolSetEntity)
set_name_to_class_name() {
  local set_name="$1"
  local class_name=""
  
  # Split by hyphens and underscores, capitalize each part, and join
  IFS='-_' read -ra PARTS <<< "$set_name"
  for part in "${PARTS[@]}"; do
    # Capitalize first letter of each part
    class_name+="$(tr '[:lower:]' '[:upper:]' <<< "${part:0:1}")${part:1}"
  done
  
  # Add "Entity" suffix
  echo "${class_name}Entity"
}

# --- Helper Function for Linking Dev Files ---
_link_dev_files() {
  local TARGET_DIR="${1:-.}" # Default to current directory if not provided
  mkdir -p "$TARGET_DIR" # Ensure target directory exists

  # Define Source and Target Paths for dev links
  local SOURCE_ENTITY_TYPES="$SOURCE_SERVER_DIR/entity_types"
  local TARGET_ENTITY_TYPES="$TARGET_DIR/entity_types"
  local SOURCE_DOCKER_COMPOSE="$SOURCE_SERVER_DIR/docker-compose.yml"
  local TARGET_DOCKER_COMPOSE="$TARGET_DIR/docker-compose.yml"

  # Create/Update Symlinks for dev files
  echo "Linking entity types to $TARGET_ENTITY_TYPES"
  ln -sf "$SOURCE_ENTITY_TYPES" "$TARGET_ENTITY_TYPES"

  echo "Linking docker-compose.yml to $TARGET_DOCKER_COMPOSE"
  ln -sf "$SOURCE_DOCKER_COMPOSE" "$TARGET_DOCKER_COMPOSE"

  echo "Graphiti dev links created successfully in $TARGET_DIR."
}

# --- Helper Function for Setting Up Rules ---
_setup_rules() {
  local PROJECT_NAME="$1"
  local TARGET_DIR="${2:-.}" # Default target directory to current if not provided

  # Validate PROJECT_NAME format (optional, but good practice)
  if ! [[ "$PROJECT_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: Invalid PROJECT_NAME. Use only letters, numbers, underscores, and hyphens."
    exit 1
  fi

  # Define paths
  local CURSOR_RULES_DIR="$TARGET_DIR/.cursor/rules/graphiti"
  local SOURCE_CORE_RULE="$SOURCE_SERVER_DIR/rules/graphiti-mcp-core-rules.md"
  local SOURCE_MAINT_RULE="$SOURCE_SERVER_DIR/rules/graphiti-knowledge-graph-maintenance.md"
  local TARGET_CORE_RULE_LINK="$CURSOR_RULES_DIR/graphiti-mcp-core-rules.mdc"
  local TARGET_MAINT_RULE_LINK="$CURSOR_RULES_DIR/graphiti-knowledge-graph-maintenance.mdc"
  local TARGET_SCHEMA_FILE="$CURSOR_RULES_DIR/graphiti-$PROJECT_NAME-schema.mdc"
  local SCHEMA_TEMPLATE_FILE="$SOURCE_SERVER_DIR/rules/templates/project_schema_template.md"

  echo "Setting up Graphiti Cursor rules for project '$PROJECT_NAME' in $TARGET_DIR"

  # Create target directory
  mkdir -p "$CURSOR_RULES_DIR"
  echo "Created rules directory: $CURSOR_RULES_DIR"

  # Check source files exist before linking/generating
  if [ ! -f "$SOURCE_CORE_RULE" ]; then
    echo "Error: Source rule file not found: $SOURCE_CORE_RULE"
    exit 1
  fi
  if [ ! -f "$SOURCE_MAINT_RULE" ]; then
    echo "Error: Source rule file not found: $SOURCE_MAINT_RULE"
    exit 1
  fi
  if [ ! -f "$SCHEMA_TEMPLATE_FILE" ]; then
    echo "Error: Schema template file not found: $SCHEMA_TEMPLATE_FILE"
    exit 1
  fi

  # Create symlinks
  echo "Linking core rule: $TARGET_CORE_RULE_LINK -> $SOURCE_CORE_RULE"
  ln -sf "$SOURCE_CORE_RULE" "$TARGET_CORE_RULE_LINK"

  echo "Linking maintenance rule: $TARGET_MAINT_RULE_LINK -> $SOURCE_MAINT_RULE"
  ln -sf "$SOURCE_MAINT_RULE" "$TARGET_MAINT_RULE_LINK"

  # Generate template project schema file from template (.md -> .mdc)
  if [ -e "$TARGET_SCHEMA_FILE" ]; then
    echo "Warning: Project schema file already exists, skipping template generation: $TARGET_SCHEMA_FILE"
  else
    echo "Generating template project schema file: $TARGET_SCHEMA_FILE"
    sed "s/__PROJECT_NAME__/$PROJECT_NAME/g" "$SCHEMA_TEMPLATE_FILE" > "$TARGET_SCHEMA_FILE"
  fi

  echo "Graphiti Cursor rules setup complete for project '$PROJECT_NAME'."
}

# Function to find the repository path based on script location
detect_repo_path() {
  # Get the real path of the script (resolving any symlinks)
  local SCRIPT_PATH=""
  
  # First attempt - use readlink if available
  if command -v readlink >/dev/null 2>&1; then
    # Check if readlink -f is supported (Linux/BSD)
    if readlink -f / >/dev/null 2>&1; then
      SCRIPT_PATH=$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || readlink -f "$0" 2>/dev/null)
    else
      # For macOS, which doesn't support readlink -f
      SCRIPT_PATH=$(perl -MCwd -e 'print Cwd::abs_path shift' "${BASH_SOURCE[0]}" 2>/dev/null || perl -MCwd -e 'print Cwd::abs_path shift' "$0" 2>/dev/null)
    fi
  fi
  
  # Fallback if readlink or perl failed
  if [ -z "$SCRIPT_PATH" ]; then
    SCRIPT_PATH="${BASH_SOURCE[0]:-$0}"
  fi
  
  echo "Debug: Script path resolved to: $SCRIPT_PATH" >&2
  
  # Get the script directory
  local SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
  echo "Debug: Script directory: $SCRIPT_DIR" >&2
  
  # Check if we're in the expected directory structure
  # We know the script should be in mcp_server/scripts/
  # First possibility: script is executed from its original location
  if [[ "$SCRIPT_DIR" == */mcp_server/scripts ]]; then
    # Go up two levels to get the repo root
    local REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
    echo "Debug: Detected repo root (direct): $REPO_ROOT" >&2
    
    if [ -d "$REPO_ROOT/mcp_server" ] && [ -d "$REPO_ROOT/mcp_server/entity_types" ]; then
      echo "$REPO_ROOT"
      return 0
    fi
  fi
  
  # Second possibility: we need to search for the repo structure
  # Try the current directory first
  local CURRENT_DIR="$(pwd)"
  echo "Debug: Checking current directory: $CURRENT_DIR" >&2
  
  if [ -d "$CURRENT_DIR/mcp_server" ] && [ -d "$CURRENT_DIR/mcp_server/entity_types" ]; then
    echo "Debug: Found repo structure in current directory" >&2
    echo "$CURRENT_DIR"
    return 0
  fi
  
  # Try one level up (in case we're in a subdirectory of the repo)
  local PARENT_DIR="$(cd .. && pwd)"
  echo "Debug: Checking parent directory: $PARENT_DIR" >&2
  
  if [ -d "$PARENT_DIR/mcp_server" ] && [ -d "$PARENT_DIR/mcp_server/entity_types" ]; then
    echo "Debug: Found repo structure in parent directory" >&2
    echo "$PARENT_DIR"
    return 0
  fi
  
  # If we got here, we couldn't find the repo root
  echo "Debug: Could not find repository structure" >&2
  return 1
}

# Function to offer saving the path to shell config
save_path_to_shell_config() {
  local PATH_TO_SAVE="$1"
  local CONFIG_FILE=""
  
  # Detect which shell config file to use
  if [ -n "$BASH_VERSION" ]; then
    CONFIG_FILE="$HOME/.bashrc"
  elif [ -n "$ZSH_VERSION" ]; then
    CONFIG_FILE="$HOME/.zshrc"
  else
    # Try to detect shell from process
    local SHELL_NAME="$(basename "$SHELL")"
    case "$SHELL_NAME" in
      bash) CONFIG_FILE="$HOME/.bashrc" ;;
      zsh) CONFIG_FILE="$HOME/.zshrc" ;;
      *) 
        echo "Could not determine your shell configuration file."
        echo "Please manually add the following line to your shell configuration:"
        echo "export MCP_GRAPHITI_REPO_PATH=\"$PATH_TO_SAVE\""
        return 1
        ;;
    esac
  fi
  
  # Ask user for confirmation before modifying their shell config
  echo -n "Would you like to permanently save MCP_GRAPHITI_REPO_PATH=\"$PATH_TO_SAVE\" to $CONFIG_FILE? (y/n): "
  read -r CONFIRM
  
  if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
    echo "" >> "$CONFIG_FILE"
    echo "# Added by graphiti script" >> "$CONFIG_FILE"
    echo "export MCP_GRAPHITI_REPO_PATH=\"$PATH_TO_SAVE\"" >> "$CONFIG_FILE"
    echo "Path saved to $CONFIG_FILE. Please restart your terminal or run 'source $CONFIG_FILE' to apply."
    return 0
  else
    echo "Path not saved. You'll need to set MCP_GRAPHITI_REPO_PATH manually each time."
    echo "You can do this by running: export MCP_GRAPHITI_REPO_PATH=\"$PATH_TO_SAVE\""
    return 1
  fi
}

# Check for help flag
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
  usage
fi

# 1. Check and Determine Source Path
if [ -z "$MCP_GRAPHITI_REPO_PATH" ]; then
  echo "MCP_GRAPHITI_REPO_PATH is not set. Attempting to auto-detect..."
  
  # Try to auto-detect the repository path based on script location
  AUTO_DETECTED_PATH=$(detect_repo_path)
  
  if [ -n "$AUTO_DETECTED_PATH" ]; then
    echo "Detected repository path: $AUTO_DETECTED_PATH"
    export MCP_GRAPHITI_REPO_PATH="$AUTO_DETECTED_PATH"
    
    # Offer to save it permanently
    save_path_to_shell_config "$AUTO_DETECTED_PATH"
  else
    echo "Error: Could not auto-detect the repository path."
    echo "Please set the MCP_GRAPHITI_REPO_PATH environment variable manually."
    echo "Example: export MCP_GRAPHITI_REPO_PATH=/path/to/mcp-graphiti"
    exit 1
  fi
fi

SOURCE_SERVER_DIR="$MCP_GRAPHITI_REPO_PATH/mcp_server"
if [ ! -d "$SOURCE_SERVER_DIR" ]; then
  echo "Error: Source directory not found: $SOURCE_SERVER_DIR"
  echo "Please ensure MCP_GRAPHITI_REPO_PATH is set correctly."
  exit 1
fi

# 2. Parse command and arguments
COMMAND="${1:-link-dev-files}" # Default to link-dev-files if no command provided
shift || true # Shift arguments even if $1 was empty (no command given). Use || true to prevent exit on error if no args.

# Handle commands using if/elif/else structure
if [[ "$COMMAND" == "init" ]]; then
  PROJECT_NAME="$1"
  TARGET_DIR="${2:-.}" # Default target directory to current if not provided

  if [ -z "$PROJECT_NAME" ]; then
    echo "Error: Missing PROJECT_NAME argument for init command."
    echo "Usage: graphiti init PROJECT_NAME [TARGET_DIRECTORY]"
    exit 1
  fi

  echo "Initializing Graphiti project '$PROJECT_NAME' in '$TARGET_DIR'..."

  # Call the helper functions
  _link_dev_files "$TARGET_DIR"
  _setup_rules "$PROJECT_NAME" "$TARGET_DIR"

  echo "Graphiti project '$PROJECT_NAME' initialization complete."
  exit 0

elif [[ "$COMMAND" == "up" ]]; then
  # Check for detached mode flag
  DETACHED=""
  if [[ "$1" == "-d" ]]; then
    DETACHED="-d"
    shift
  fi

  # We need to run docker-compose from the mcp_server directory
  MCP_SERVER_DIR="$MCP_GRAPHITI_REPO_PATH/mcp_server"
  
  if [ ! -d "$MCP_SERVER_DIR" ]; then
    echo "Error: mcp_server directory not found at $MCP_SERVER_DIR"
    exit 1
  fi

  # Save current directory to return to it afterwards
  CURRENT_DIR=$(pwd)
  
  echo "Starting Graphiti containers with docker compose..."
  echo "This will rebuild containers to incorporate any changes."
  echo "Running Docker Compose from: $MCP_SERVER_DIR"
  
  # Change to mcp_server directory where docker-compose.yml is located
  cd "$MCP_SERVER_DIR"
  
  # Run docker compose up with build and force-recreate flags
  if [ -n "$DETACHED" ]; then
    echo "Running in detached mode."
    docker compose up --build --force-recreate -d
  else
    docker compose up --build --force-recreate
  fi
  
  # Return to original directory
  cd "$CURRENT_DIR"
  
  echo "Docker compose up completed."
  exit 0

elif [[ "$COMMAND" == "down" ]]; then
  # We need to run docker-compose from the mcp_server directory
  MCP_SERVER_DIR="$MCP_GRAPHITI_REPO_PATH/mcp_server"
  
  if [ ! -d "$MCP_SERVER_DIR" ]; then
    echo "Error: mcp_server directory not found at $MCP_SERVER_DIR"
    exit 1
  fi

  # Save current directory to return to it afterwards
  CURRENT_DIR=$(pwd)
  
  echo "Stopping and removing Graphiti containers..."
  echo "Running Docker Compose from: $MCP_SERVER_DIR"
  
  # Change to mcp_server directory where docker-compose.yml is located
  cd "$MCP_SERVER_DIR"
  
  # Run docker compose down to stop and remove containers
  docker compose down
  
  # Return to original directory
  cd "$CURRENT_DIR"
  
  echo "Docker compose down completed."
  exit 0

elif [[ "$COMMAND" == "add-entities" ]]; then
  # Get SET_NAME from first remaining argument
  SET_NAME="$1"
  
  # Input validation
  if [ -z "$SET_NAME" ]; then
    echo "Error: Missing SET_NAME argument."
    echo "Usage: graphiti add-entities SET_NAME"
    exit 1
  fi
  
  # Validate SET_NAME format (only allow letters, numbers, underscores, hyphens)
  if ! [[ "$SET_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: Invalid SET_NAME. Use only letters, numbers, underscores, and hyphens."
    exit 1
  fi
  
  # Path construction
  ENTITY_TYPES_DIR="$SOURCE_SERVER_DIR/entity_types"
  NEW_SET_DIR="$ENTITY_TYPES_DIR/$SET_NAME"
  
  # Check if directory already exists
  if [ -d "$NEW_SET_DIR" ]; then
    echo "Error: Entity type set '$SET_NAME' already exists at: $NEW_SET_DIR"
    exit 1
  fi
  
  # Create the new directory
  mkdir -p "$NEW_SET_DIR"
  echo "Created entity type set directory: $NEW_SET_DIR"
  
  # Generate class name from SET_NAME
  CLASS_NAME=$(set_name_to_class_name "$SET_NAME")
  
  # Create entity file using the custom_entity_example.py as a template
  ENTITY_FILE="$NEW_SET_DIR/entity.py"
  TEMPLATE_FILE="$SOURCE_SERVER_DIR/entity_types/example/custom_entity_example.py"
  
  # Check if template file exists
  if [ ! -f "$TEMPLATE_FILE" ]; then
    echo "Warning: Template file not found: $TEMPLATE_FILE"
    echo "Creating a minimal entity file instead."
    
    # Create a minimal entity file
    cat > "$ENTITY_FILE" << EOF
from pydantic import BaseModel, Field


class $CLASS_NAME(BaseModel):
    """Example entity for the '$SET_NAME' set."""
    
    example_field: str = Field(
        ...,
        description='An example field.',
    )
EOF
  else
    # Read the template and replace the class name
    sed -e "s/class Product/class $CLASS_NAME/" \
        -e "s/A Product/$CLASS_NAME/" \
        -e "s/products/${SET_NAME}s/" \
        -e "s/the product/the ${SET_NAME}/" \
        "$TEMPLATE_FILE" > "$ENTITY_FILE"
    
    echo "Created entity file using template: $ENTITY_FILE"
  fi
  
  echo "Entity set '$SET_NAME' successfully created."
  exit 0

elif [[ "$COMMAND" == "setup-rules" ]]; then
  PROJECT_NAME="$1"
  TARGET_DIR="${2:-.}" # Default target directory to current if not provided

  if [ -z "$PROJECT_NAME" ]; then
    echo "Error: Missing PROJECT_NAME argument for setup-rules command."
    echo "Usage: graphiti setup-rules PROJECT_NAME [TARGET_DIRECTORY]"
    exit 1
  fi

  # Call the helper function (validation is inside the helper)
  _setup_rules "$PROJECT_NAME" "$TARGET_DIR"
  exit 0

elif [[ "$COMMAND" == "link-dev-files" ]]; then
  # Determine Target Directory for dev links
  TARGET_DIR="${1:-.}" # Use first arg after 'link-dev-files' or default to '.' if no command/args

  # Call the helper function
  _link_dev_files "$TARGET_DIR"
  exit 0

else
  echo "Error: Unknown command '$COMMAND'"
  usage
fi 